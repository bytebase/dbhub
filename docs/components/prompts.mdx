---
title: "Prompts"
---

MCP Prompts provide AI-assisted capabilities for database operations. These prompts help users generate SQL queries and understand database elements using natural language.

## Supported Prompts

| Prompt              | Command Name   | PostgreSQL | MySQL | MariaDB | SQL Server | SQLite |
| ------------------- | -------------- | :--------: | :---: | :-----: | :--------: | ------ |
| Generate SQL        | `generate_sql` |     ✅     |  ✅   |   ✅    |     ✅     | ✅     |
| Explain DB Elements | `explain_db`   |     ✅     |  ✅   |   ✅    |     ✅     | ✅     |

## Generate SQL

Transform natural language descriptions into SQL queries. The AI analyzes your database schema and generates appropriate SQL statements tailored to your database structure.

### How It Works

1. **Schema Analysis**: The AI understands your database schema, including tables, columns, relationships, and constraints
2. **Natural Language Processing**: Your request is interpreted to understand the desired operation
3. **SQL Generation**: A SQL query is generated that matches your database dialect and schema

### Example Prompts

<AccordionGroup>
  <Accordion title="Simple Queries">
    **Prompt:** "Show me all active users"

    **Generated SQL:**
    ```sql
    SELECT * FROM users WHERE status = 'active';
    ```

    **Prompt:** "Get the 10 most recent orders"

    **Generated SQL:**
    ```sql
    SELECT * FROM orders ORDER BY created_at DESC LIMIT 10;
    ```
  </Accordion>

  <Accordion title="Aggregations and Analytics">
    **Prompt:** "Calculate total revenue by product category"

    **Generated SQL:**
    ```sql
    SELECT
      c.name AS category,
      SUM(oi.quantity * oi.price) AS total_revenue
    FROM categories c
    JOIN products p ON c.id = p.category_id
    JOIN order_items oi ON p.id = oi.product_id
    GROUP BY c.id, c.name
    ORDER BY total_revenue DESC;
    ```

    **Prompt:** "Show monthly sales trends for 2024"

    **Generated SQL:**
    ```sql
    SELECT
      DATE_TRUNC('month', created_at) AS month,
      COUNT(*) AS order_count,
      SUM(total_amount) AS total_sales
    FROM orders
    WHERE EXTRACT(YEAR FROM created_at) = 2024
    GROUP BY month
    ORDER BY month;
    ```
  </Accordion>

  <Accordion title="Complex Joins and Subqueries">
    **Prompt:** "Find employees with salaries above their department average"

    **Generated SQL:**
    ```sql
    SELECT
      e.id,
      e.name,
      e.salary,
      d.name AS department
    FROM employees e
    JOIN departments d ON e.department_id = d.id
    WHERE e.salary > (
      SELECT AVG(salary)
      FROM employees
      WHERE department_id = e.department_id
    )
    ORDER BY e.salary DESC;
    ```

    **Prompt:** "List customers who haven't ordered in the last 90 days"

    **Generated SQL:**
    ```sql
    SELECT
      c.id,
      c.name,
      c.email,
      MAX(o.created_at) AS last_order_date
    FROM customers c
    LEFT JOIN orders o ON c.id = o.customer_id
    GROUP BY c.id, c.name, c.email
    HAVING MAX(o.created_at) < CURRENT_DATE - INTERVAL '90 days'
    OR MAX(o.created_at) IS NULL
    ORDER BY last_order_date DESC NULLS LAST;
    ```
  </Accordion>

  <Accordion title="Time-Based Queries">
    **Prompt:** "Show all users who signed up in the last 30 days"

    **Generated SQL:**
    ```sql
    SELECT * FROM users
    WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
    ORDER BY created_at DESC;
    ```

    **Prompt:** "Get hourly user registrations for today"

    **Generated SQL:**
    ```sql
    SELECT
      DATE_TRUNC('hour', created_at) AS hour,
      COUNT(*) AS registrations
    FROM users
    WHERE DATE(created_at) = CURRENT_DATE
    GROUP BY hour
    ORDER BY hour;
    ```
  </Accordion>
</AccordionGroup>

## Explain DB Elements

Get AI-generated explanations of database tables, columns, relationships, and data patterns. This is useful for understanding unfamiliar databases, onboarding new team members, or documenting existing schemas.

### How It Works

1. **Schema Inspection**: The AI examines table structures, column types, constraints, and indexes
2. **Pattern Recognition**: Identifies common patterns like timestamps, foreign keys, and naming conventions
3. **Contextual Explanation**: Provides clear explanations tailored to your database's domain

### Example Prompts

<AccordionGroup>
  <Accordion title="Table Explanations">
    **Prompt:** "Explain the users table structure"

    **Response:**
    ```
    The 'users' table stores user account information with the following structure:

    Primary Fields:
    - id: Unique identifier (auto-incrementing integer)
    - email: User's email address (unique, used for authentication)
    - name: User's display name

    Status & Metadata:
    - status: Account status ('active', 'inactive', 'suspended')
    - created_at: Account creation timestamp
    - updated_at: Last modification timestamp

    Relationships:
    - Referenced by 'orders' table via user_id foreign key
    - Referenced by 'user_preferences' table via user_id foreign key

    Indexes:
    - Primary key on 'id'
    - Unique index on 'email'
    - Index on 'status' for filtering active users
    ```
  </Accordion>

  <Accordion title="Column Explanations">
    **Prompt:** "What is the purpose of the created_at column?"

    **Response:**
    ```
    The 'created_at' column is a timestamp field that tracks when each record
    was first inserted into the table.

    Key characteristics:
    - Type: TIMESTAMP
    - Default: CURRENT_TIMESTAMP (automatically set on insert)
    - Nullable: NO (always has a value)
    - Timezone: Stored in UTC

    Common uses:
    - Audit trail for record creation
    - Filtering recent records (e.g., "created in last 30 days")
    - Sorting records chronologically
    - Analytics and reporting on creation trends
    ```
  </Accordion>

  <Accordion title="Relationship Explanations">
    **Prompt:** "Explain the relationships between orders, customers, and products"

    **Response:**
    ```
    The database implements a classic e-commerce order model:

    customers → orders (One-to-Many):
    - Each customer can have multiple orders
    - orders.customer_id references customers.id
    - Enforced by foreign key constraint with CASCADE delete

    orders → order_items (One-to-Many):
    - Each order contains multiple line items
    - order_items.order_id references orders.id
    - order_items is a junction table linking orders to products

    products → order_items (One-to-Many):
    - Each product can appear in multiple order line items
    - order_items.product_id references products.id
    - Stores quantity and price at time of purchase

    Data Flow:
    1. Customer places order → creates orders record
    2. Items added to order → creates order_items records
    3. Each order_item links to a product and stores snapshot of price/quantity
    ```
  </Accordion>

  <Accordion title="Schema Overview">
    **Prompt:** "Give me an overview of the database schema"

    **Response:**
    ```
    This database implements a multi-tenant SaaS application with the following modules:

    User Management:
    - users: User accounts and authentication
    - user_roles: Role assignments (admin, user, viewer)
    - user_sessions: Active login sessions

    Organization:
    - organizations: Tenant/company records
    - organization_members: User-to-organization relationships
    - organization_settings: Per-tenant configuration

    Core Business:
    - projects: Main workspace entities
    - tasks: Work items within projects
    - comments: Discussion threads on tasks
    - attachments: File uploads linked to tasks

    System:
    - audit_logs: Track all user actions
    - notifications: User notification queue
    - webhooks: External integration endpoints

    Design Patterns:
    - Soft deletes: deleted_at column for reversible deletions
    - Timestamps: created_at/updated_at on all tables
    - UUIDs: Primary keys use UUID for distributed systems
    ```
  </Accordion>
</AccordionGroup>

## Context-Aware Prompts

Both `generate_sql` and `explain_db` prompts leverage your database schema context to provide accurate, database-specific responses. The AI considers:

- **Database Type**: Generates SQL syntax appropriate for PostgreSQL, MySQL, SQL Server, etc.
- **Schema Structure**: Uses actual table and column names from your database
- **Relationships**: Understands foreign key relationships and generates proper JOIN conditions
- **Data Types**: Considers column types when generating WHERE clauses and comparisons
- **Naming Conventions**: Adapts to your database's naming patterns (snake_case, camelCase, etc.)

<Note>
Prompts analyze the database schema at runtime, so they always work with your current database structure without requiring manual configuration.
</Note>
